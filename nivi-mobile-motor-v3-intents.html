<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Nivi IA — Mobile Canon (v0+v1)</title>

  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #05080f;
    }
    canvas {
      width: 100vw;
      height: 100vh;
      display: block;
    }
  </style>
</head>

<body>
  <canvas id="stage"></canvas>

  <!-- ===== LIBS ===== -->
  <script src="./libs/pixi.min.js"></script>
  <script src="./libs/live2dcubismcore.min.js"></script>
  <script src="./libs/cubism4.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pixi-live2d-display/dist/pixi-live2d-display.min.js"></script>

  <script src="./verses.js"></script>
  <script src="./verse_picker.js"></script>
  <script>
  (async () => {
    "use strict";

    /* =========================================================
       Nivi IA — Reescritura Mobile Canon
       v0 + v1: base + modelo + velo (sin audio / sin UI / sin estrellas / sin rects)
       ========================================================= */

    
    /* =========================================================
       AUDIO (Paso 4) — activado por toque
       ========================================================= */
    const bgm = new Audio();
    bgm.src = "assets/audio/music.mp3"; // <-- tu canción de 3 min aquí
    bgm.loop = false;
    bgm.volume = 0.0;

    let audioUnlocked = false;
    let wakingUp = false;
    let awakened = false; // historia pausada hasta despertar

/* =========================================================
       1) PIXI APP SETUP
       ========================================================= */
    PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.LINEAR;

    const DPR = Math.min(window.devicePixelRatio || 1, 2);
    const app = new PIXI.Application({
      view: document.getElementById("stage"),
      backgroundAlpha: 0,
      antialias: true,
      autoDensity: true,
      resolution: DPR,
      resizeTo: window,
      powerPreference: "high-performance"
    });

    /* =========================================================
       2) CAPAS / ORDEN (IMPORTANTÍSIMO)
       =========================================================
       1) rectLayer (fondo)      -> (aún vacío en v0+v1)
       2) model
       3) nightOverlay (velo)
       4) starLayer              -> (aún vacío)
       5) zzzLayer               -> (aún vacío)
       6) uiLayer                -> (aún vacío)
       ========================================================= */
    const rectLayer = new PIXI.Container();
    const starLayer = new PIXI.Container();
    const zzzLayer  = new PIXI.Container();
    const uiLayer   = new PIXI.Container();
    const nightOverlay = new PIXI.Graphics();

        const curtain = new PIXI.Graphics(); // cortina/umbral
    const curtainTextA = new PIXI.Text("", {
      fontFamily: "Inter",
      fontWeight: "300",
      fontSize: 18,
      fill: 0xEAF1FF,
      letterSpacing: 1,
      dropShadow: true,
      dropShadowColor: 0xAFCBFF,
      dropShadowBlur: 4,
      dropShadowAlpha: 0.18,
      dropShadowDistance: 0,
      padding: 18
    });
    curtainTextA.anchor.set(0.5);
    const curtainTextB = new PIXI.Text("", {
      fontFamily: "Inter",
      fontWeight: "300",
      fontSize: 20,
      fill: 0xEAF1FF,
      letterSpacing: 1,
      dropShadow: true,
      dropShadowColor: 0xAFCBFF,
      dropShadowBlur: 4,
      dropShadowAlpha: 0.18,
      dropShadowDistance: 0,
      padding: 18
    });
    curtainTextB.anchor.set(0.5);

    const wakeHint = new PIXI.Text("tap to awaken", {
      fontFamily: "Inter",
      fontWeight: "400",
      fontSize: 12,
      fill: 0xAFC2E8,
      letterSpacing: 2,
      dropShadow: true,
      dropShadowColor: 0xAFCBFF,
      dropShadowBlur: 2,
      dropShadowAlpha: 0.12,
      dropShadowDistance: 0,
      padding: 14
    });
    wakeHint.anchor.set(0.5);
    wakeHint.alpha = 0;

app.stage.addChild(rectLayer);

    /* =========================================================
       3) MODELO (v1)
       ========================================================= */
    const model = await PIXI.live2d.Live2DModel.from(
      "assets/models/nivi/nivi.model3.json"
    );
    model.anchor.set(0.5, 1);

    /* ================= HELPERS (Live2D params) ================= */
    function core(){ return model.internalModel.coreModel; }
    function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
    function setParam(id, v){ core().setParameterValueById(id, clamp(v, -30, 30)); }

    app.stage.addChild(model);
    app.stage.addChild(nightOverlay);
    app.stage.addChild(starLayer);
    app.stage.addChild(zzzLayer);
    app.stage.addChild(uiLayer);
    app.stage.addChild(curtain);
    app.stage.addChild(curtainTextA);
    app.stage.addChild(curtainTextB);
    app.stage.addChild(wakeHint);


    /* =========================================================
       4) UI (poster) — móvil canon (v2)
       ========================================================= */
    // Título
    const titleText = new PIXI.Text("Nivi?", {
      fontFamily: "Inter",
      fontWeight: "700",
      fontSize: 44,           // móvil fijo
      fill: 0xEAF1FF,
      align: "center",
      letterSpacing: 1,
      padding: 14,
      dropShadow: true,
      dropShadowColor: 0xAFCBFF,
      dropShadowBlur: 6,
      dropShadowAngle: Math.PI / 2,
      dropShadowDistance: 0,
      dropShadowAlpha: 0.35
    });
    titleText.anchor.set(0.5);

    // Subtítulo
    const subText = new PIXI.Text("COMING SOON", {
      fontFamily: "Inter",
      fontWeight: "500",
      fontSize: 14,           // móvil fijo
      fill: 0xAFC2E8,
      align: "center",
      letterSpacing: 4
    });
    subText.anchor.set(0.5);

    // Texto narrativo base (…)
    const dateText = new PIXI.Text("hm…", {
      fontFamily: "Inter",
      fontWeight: "300",
      fontSize: 14,           // móvil fijo
      fill: 0xAFC2E8,
      align: "center",
      letterSpacing: 2,
      dropShadow: true,
      dropShadowColor: 0xAFCBFF,
      dropShadowBlur: 3,
      dropShadowAngle: Math.PI / 2,
      dropShadowDistance: 0,
      dropShadowAlpha: 0.18
    });
    dateText.anchor.set(0.5);

    // Segundo texto para crossfade (lo usaremos en v3)
    const dateTextB = new PIXI.Text(dateText.text, dateText.style);
    dateTextB.anchor.set(0.5);
    dateTextB.alpha = 0;

    // “Initializing...” (con puntos)
    const initText = new PIXI.Text("Initializing", {
      fontFamily: "Inter",
      fontWeight: "300",
      fontSize: 12,           // móvil fijo
      fill: 0xAFC2E8,
      align: "center",
      letterSpacing: 1
    });
    initText.anchor.set(0.5);

    // Fecha / availability
    const availText = new PIXI.Text("ニーバーリースー！", {
      fontFamily: "Inter",
      fontWeight: "500",
      fontSize: 14,           // móvil fijo
      fill: 0xAEA69C,
      dropShadow: true,
      dropShadowColor: 0xF2EFEA,
      dropShadowBlur: 2.5,
      dropShadowAngle: Math.PI / 2,
      dropShadowDistance: 0,
      dropShadowAlpha: 0.18
    });
    availText.anchor.set(0.5);

    // Línea fina separadora
    const rule = new PIXI.Graphics();

    uiLayer.addChild(titleText, subText, rule, dateText, dateTextB, initText, availText);
    uiLayer.alpha = 0.95;

    /* =========================================================
       4.1) Inicializing: frases aleatorias + puntos (sin audio)
       ========================================================= */
    const TECH_LINES = [
        "Listening", "Learning", "Feeling",
	"Breathing", "Waiting", "Remembering",
	"Dreaming", "Becoming"
    ];

    let initBase = "Initializing";
    let dots = 0;
    let dotsTimer = 0;
    const DOTS_INTERVAL = 0.45;

    let lastIndex = -1;
    let tapCooldown = 0;

    function pickRandomIndex(len, avoid){
      if (len <= 1) return 0;
      let i = Math.floor(Math.random() * len);
      if (i === avoid) i = (i + 1) % len;
      return i;
    }

    function applyRandomText(){
      const i = pickRandomIndex(TECH_LINES.length, lastIndex);
      lastIndex = i;
      initBase = TECH_LINES[i];
      dotsTimer = DOTS_INTERVAL; // refresco inmediato
    }

    function updateInitializingDots(dt){
      dotsTimer += dt;
      if (dotsTimer >= DOTS_INTERVAL){
        dotsTimer = 0;
        dots = (dots + 1) % 4; // 0..3
      }
      initText.text = initBase + ".".repeat(dots);
    }

    // Estado inicial aleatorio
    applyRandomText();

    // Tap/click para cambiar frase (suave, sin spam)
    app.view.addEventListener("pointerdown", () => {
      if (tapCooldown > 0) return;
      tapCooldown = 0.18;
      applyRandomText();
    }, { passive: true });

    /* =========================================================
       4.2) Glow suave del título (v2)
       ========================================================= */
    let titleGlowT = Math.random() * Math.PI * 2;

    function updateTitleGlow(dt){
      titleGlowT += dt * 2.8;
      const glowPulse = 0.5 + Math.sin(titleGlowT) * 0.5;
      titleText.style.dropShadowAlpha = 2.40 + glowPulse * 2.50;
      titleText.style.dropShadowBlur  = 6 + glowPulse * 5;
    }

    /* =========================================================
       4.3) Layout de UI (poster) — móvil canon
       ========================================================= */
    function layoutPresentation(){
      const w = app.renderer.width / DPR;
      const h = app.renderer.height / DPR;

      const topY = h * 0.10;

      titleText.x = w * 0.5;
      titleText.y = topY;

      subText.x = w * 0.5;
      subText.y = topY + 42;

      rule.clear();
      rule.lineStyle(1, 0xAFC2E8, 0.25);
      const lineW = Math.min(260, w * 0.55);
      rule.moveTo(w * 0.5 - lineW/2, subText.y + 18);
      rule.lineTo(w * 0.5 + lineW/2, subText.y + 18);

      dateText.x = w * 0.5;
      dateText.y = subText.y + 38;
      dateTextB.x = dateText.x;
      dateTextB.y = dateText.y;

      const bottomY = h * 0.86;
      initText.x = w * 0.5;
      initText.y = bottomY;

      availText.x = w * 0.5;
      availText.y = bottomY + 22;

      uiLayer.alpha = 0.95;
    }


    /* =========================================================
       7) HISTORIA (hm… → frases → final lock) — móvil canon
       =========================================================
       - Crossfade suave (sin flashes)
       - Todas las frases comparten la misma respiración visible
       - Al llegar al final: la historia se detiene, pero el mundo sigue vivo
       ========================================================= */
    const HM_BASE = "…";

    const STORY = [
      "hm…",
      "Ve…",
      "Venus…",
      "sabes qu…",
      "…",
      "kho kho…",
      "Zzz…",
      "tu nombre…",
      "es…",
      "oye…",
      "espera…",
      "casi…",
      "despierto…"
    ];

    // Intervalo entre gotas (12–18s)
    let nextDropIn = 12 + Math.random() * 6;

    // Respiración compartida del texto
    let textBreathT = Math.random() * Math.PI * 2;
    const TEXT_BREATH_PERIOD = 9.5;      // segundos por ciclo
    const TEXT_BREATH_ALPHA_AMP = 0.07;  // 7% de alpha

    // Crossfade state
    let shownText = HM_BASE;
    let nextText = null;

    let xState = "idle"; // idle -> fade -> final
    let xT = 0;

    const X = {
      fade: 1.10
    };

    const PROMISE_ALPHA = 0.96;
    let storyDone = false;
    let storyIndex = 0;

    function scheduleNextDrop(){
      nextDropIn = 12 + Math.random() * 6;
    }

    function startDrop(){
      if (storyDone) return;

      const finalLine = STORY[STORY.length - 1];

      if (storyIndex >= STORY.length){
        storyDone = true;
        shownText = finalLine;

        xState = "final";
        xT = 0;
        nextText = null;

        dateText.text  = shownText;
        dateText.alpha = PROMISE_ALPHA;

        dateTextB.text  = "";
        dateTextB.alpha = 0;

        nextDropIn = Number.POSITIVE_INFINITY;
        return;
      }

      nextText = STORY[storyIndex];
      storyIndex++;

      // Prepara crossfade
      dateText.text = shownText;
      dateTextB.text = nextText;

      dateText.alpha = 1.0;
      dateTextB.alpha = 0.0;

      xState = "fade";
      xT = 0;
    }

    function applySharedTextBreath(dt){
      textBreathT += dt * (Math.PI * 2 / TEXT_BREATH_PERIOD);
      const b = 0.5 + Math.sin(textBreathT) * 0.5; // 0..1
      const a = 1.0 - TEXT_BREATH_ALPHA_AMP/2 + b * TEXT_BREATH_ALPHA_AMP;

      // sombra respirando suave (mismo gesto en ambos textos)
      const shA = 0.12 + b * 0.18;
      const shB = 2.0 + b * 2.4;

      dateText.style.dropShadowAlpha = shA;
      dateText.style.dropShadowBlur  = shB;
      dateTextB.style.dropShadowAlpha = shA;
      dateTextB.style.dropShadowBlur  = shB;

      return a;
    }

    function updateStory(dt){
      const breathA = applySharedTextBreath(dt);

      // Final lock: mantener el último verso respirando, sin avanzar nunca más
      if (storyDone || xState === "final"){
        dateText.text = shownText;
        dateText.alpha = PROMISE_ALPHA * breathA;
        dateTextB.text = "";
        dateTextB.alpha = 0;
        return;
      }

      if (xState === "idle"){
        dateText.text = shownText;
        dateText.alpha = (shownText === HM_BASE) ? 1.0 : 0.95 * breathA;
        dateTextB.alpha = 0;

        nextDropIn -= dt;
        if (nextDropIn <= 0){
          scheduleNextDrop();
          startDrop();
        }
        return;
      }

      if (xState === "fade"){
        xT += dt;
        const t = Math.min(1, xT / X.fade);
        const e = t * t * (3 - 2 * t); // smoothstep

        dateText.alpha  = (1 - e) * 0.95 * breathA;
        dateTextB.alpha = e * 0.95 * breathA;

        if (t >= 1){
          shownText = nextText ?? shownText;
          nextText = null;

          dateText.text = shownText;
          dateText.alpha = 0.95 * breathA;
          dateTextB.alpha = 0;

          // Si aterrizamos en la última línea, bloqueamos limpio
          if (shownText === STORY[STORY.length - 1]){
            storyDone = true;
            xState = "final";
            nextDropIn = Number.POSITIVE_INFINITY;
            return;
          }

          xState = "idle";
          xT = 0;
        }
        return;
      }

      // Fallback seguro
      xState = "idle";
    }

    // Estado inicial del texto
    shownText = HM_BASE;
    dateText.text = HM_BASE;
    dateText.alpha = 1.0;
    dateTextB.text = HM_BASE;
    dateTextB.alpha = 0;


    /* =========================================================
       5) FONDO: RECTÁNGULOS (parallax lateral) — móvil canon (v5)
       =========================================================
       - Ambiente suave, no invasivo
       - 3 capas con velocidades distintas
       ========================================================= */
    function rand(min, max){ return min + Math.random() * (max - min); }

    const rectLayers = [];
    const rectConfig = [
      { count: 8,  speed: 0.040, wMin: 120, wMax: 200, hMin: 4, hMax: 8, alpha: 0.015 },
      { count: 12, speed: 0.070, wMin: 60,  wMax: 120, hMin: 4, hMax: 8, alpha: 0.025 },
      { count: 16, speed: 0.100, wMin: 30,  wMax: 60,  hMin: 3, hMax: 6, alpha: 0.035 }
    ];

    function makeRect(conf, w, h){
      const g = new PIXI.Graphics();
      const rw = rand(conf.wMin, conf.wMax);
      const rh = rand(conf.hMin, conf.hMax);

      g.beginFill(0xAAC8FF, conf.alpha);
      g.drawRect(0, 0, rw, rh);
      g.endFill();

      g.x = Math.random() * w;
      g.y = Math.random() * h;

      rectLayer.addChild(g);
      return { g, rw, rh, vx: conf.speed * (Math.random() < 0.5 ? -1 : 1) };
    }

    function buildRects(){
      rectLayer.removeChildren();
      rectLayers.length = 0;

      const w = app.renderer.width / DPR;
      const h = app.renderer.height / DPR;

      rectConfig.forEach(conf => {
        const arr = [];
        for (let i = 0; i < conf.count; i++){
          arr.push(makeRect(conf, w, h));
        }
        rectLayers.push(arr);
      });
    }

    function updateRects(dt){
      const w = app.renderer.width / DPR;
      const h = app.renderer.height / DPR;

      for (let li = 0; li < rectLayers.length; li++){
        const arr = rectLayers[li];
        for (let i = 0; i < arr.length; i++){
          const r = arr[i];
          r.g.x += r.vx;

          if (r.vx > 0 && r.g.x > w + 40){
            r.g.x = -r.rw - 40;
            r.g.y = Math.random() * h;
          } else if (r.vx < 0 && r.g.x < -r.rw - 40){
            r.g.x = w + 40;
            r.g.y = Math.random() * h;
          }
        }
      }
    }


    /* =========================================================
       6) Zzz — ambiente (v6)
       ========================================================= */
    const zzzs = [];
    const Z_SEQUENCE = [
      { size: 1.2, delay: 0.0, grow: true  },
      { size: 0.8, delay: 0.9, grow: false },
      { size: 0.4, delay: 2.0, grow: false }
    ];

    function spawnZzzCycle(){
      const baseX = model.x;
      const baseY = model.y - model.height + 20;

      for (let i = 0; i < Z_SEQUENCE.length; i++){
        const seq = Z_SEQUENCE[i];

        const z = new PIXI.Text("Z", {
          fontFamily: "Comic Neue",
          fontSize: 18 * seq.size, // móvil fijo
          fill: 0xD6DEFF
        });
        z.anchor.set(0.5);
        z.alpha = 0;
        z.x = baseX;
        z.y = baseY;

        if (seq.grow) z.scale.set(0.4);

        zzzLayer.addChild(z);

        zzzs.push({
          z,
          life: -seq.delay,
          lifeMax: 4.2,
          rise: 18 + Math.random() * 6,
          drift: 6 + Math.random() * 4,
          swayPhase: Math.random() * Math.PI * 2,
          swaySpeed: 0.6 + Math.random() * 0.3,
          grow: seq.grow
        });
      }
    }

    let zzzTimer = 0;
    let nextZzz = 3.2;

    function updateZzz(dt){
      // Spawn
      zzzTimer += dt;
      if (zzzTimer > nextZzz){
        spawnZzzCycle();
        zzzTimer = 0;
        nextZzz = 3.0 + Math.random() * 0.8;
      }

      // Update existing
      for (let i = zzzs.length - 1; i >= 0; i--){
        const p = zzzs[i];
        p.life += dt;
        if (p.life < 0) continue;

        const t = p.life / p.lifeMax;

        if (t < 0.25) p.z.alpha = t / 0.25;
        else if (t > 0.85) p.z.alpha = (1 - t) / 0.15;
        else p.z.alpha = 1;

        if (p.grow && t < 0.35){
          const sc = 0.4 + (t / 0.35) * 0.6;
          p.z.scale.set(sc);
        }

        p.z.y -= p.rise * dt;
        p.swayPhase += dt * p.swaySpeed;
        p.z.x += Math.sin(p.swayPhase) * p.drift * dt;

        if (t >= 1){
          zzzLayer.removeChild(p.z);
          p.z.destroy();
          zzzs.splice(i, 1);
        }
      }
    }


    /* =========================================================
       7) ESTRELLAS — luciérnagas (v7)
       =========================================================
       - Movimiento lento y orgánico
       - Pulso suave (no compite con el texto)
       ========================================================= */
    const stars = [];
    const STAR_COUNT = 120;      // densidad actual (ajustable luego)
    const STAR_V = 0.30;         // velocidad base
    const STAR_DRIFT_MIN = 4.0;
    const STAR_DRIFT_MAX = 8.0;

    function makeStar(w, h){
      const g = new PIXI.Graphics();
      starLayer.addChild(g);
      return {
        g,
        x: Math.random() * w,
        y: Math.random() * h,
        r: rand(0.4, 2.0),
        baseAlpha: rand(0.18, 0.40),
        phase: Math.random() * Math.PI * 2,
        pulseSpeed: rand(0.25, 0.60),
        vx: (Math.random() - 0.8) * STAR_V,
        vy: (Math.random() - 0.8) * STAR_V,
        driftT: rand(STAR_DRIFT_MIN, STAR_DRIFT_MAX)
      };
    }

    function drawStar(s, alpha){
      s.g.clear();
      s.g.beginFill(0xFFFFFF, alpha);
      s.g.drawCircle(0, 0, s.r);
      s.g.endFill();
      s.g.x = s.x;
      s.g.y = s.y;
    }

    function buildStars(){
      starLayer.removeChildren();
      stars.length = 0;

      const w = app.renderer.width / DPR;
      const h = app.renderer.height / DPR;

      for (let i = 0; i < STAR_COUNT; i++){
        stars.push(makeStar(w, h));
      }
    }

    function updateStars(dt){
      const w = app.renderer.width / DPR;
      const h = app.renderer.height / DPR;

      for (let i = 0; i < stars.length; i++){
        const s = stars[i];

        s.phase += s.pulseSpeed * dt;
        const pulse = 0.5 + Math.sin(s.phase) * 0.5;
        const alpha = s.baseAlpha + pulse * 0.25;

        s.driftT -= dt;
        if (s.driftT <= 0){
          s.vx = (Math.random() - 0.8) * STAR_V;
          s.vy = (Math.random() - 0.8) * STAR_V;
          s.driftT = rand(STAR_DRIFT_MIN, STAR_DRIFT_MAX);
        }

        s.x += s.vx;
        s.y += s.vy;

        if (s.x < -10) s.x = w + 10;
        if (s.x >  w + 10) s.x = -10;
        if (s.y < -10) s.y = h + 10;
        if (s.y >  h + 10) s.y = -10;

        drawStar(s, alpha);
      }
    }

    /* =========================================================
       5) VELO NOCHE (encima del modelo, debajo de estrellas)
       ========================================================= */
    function drawNightOverlay(){
      const w = app.renderer.width / DPR;
      const h = app.renderer.height / DPR;

      nightOverlay.clear();
      nightOverlay.beginFill(0x020611, 0.28);
      nightOverlay.drawRect(0, 0, w, h);
      nightOverlay.endFill();
    }

    
    /* =========================================================
       DESPERTAR — primer toque
       ========================================================= */
    function wakeUp(){
      // No despertamos hasta que el verso termine (exist...)
      if (!typeEngine.done) return;
      if (wakingUp) return;
      wakingUp = true;

      // Ya aceptamos el despertar: no necesitamos más toques
      window.removeEventListener("pointerdown", wakeUp);
      awakened = true;

      // Audio unlock
      if (!audioUnlocked){
        audioUnlocked = true;
        bgm.play().then(() => {
          // fade in lento
        }).catch(()=>{});
      }

      curtainTarget = 0.0; // empieza a revelar el mundo
      curtainTextTarget = 0.0; // oculta el verso rápido al despertar
    }

    window.addEventListener("pointerdown", wakeUp, { passive: true });
/* =========================================================
       8) CORTINA / UMBRAL (Paso 1)
       =========================================================
       - Por ahora: solo capa negra elegante (sin interacción)
       - Más adelante: texto + toque + música + revelado
       ========================================================= */
    let curtainAlpha = 1.0; // inicia cerrada
    let curtainTarget = 1.0;
    let curtainTextFade = 1.0; // 1 visible, 0 oculto
    let curtainTextTarget = 1.0;
    const CURTAIN_TEXT_FADE_SPEED = 6.0; // rápido (en segundos)

    const CURTAIN_FADE_SPEED = 0.35; // más bajo = más lento

    let curtainTextT = Math.random() * Math.PI * 2;
    const CURTAIN_TEXT_PERIOD = 8.5;
    const CURTAIN_TEXT_AMP = 0.07;

    
    /* =========================================================
       9) MOTOR DE ESCRITURA (Intenciones) — v3 (REEMPLAZO TOTAL)
       =========================================================
       - El verso declara: intent + lines
       - El motor decide el comportamiento (cuerpo) según la intención
       - Confesión tiene 2 modos: lenta (80%) / corregida (20%)
       - Eco escribe limpio pero más lento
       - Si el verso viene como ["a","b"] (formato antiguo), asumimos intent="casual"
       ========================================================= */

    function normalizeVerse(v){
      // Formatos aceptados:
      // 1) { intent: "fragil", lines: ["a","b"], alt?: { b2?: "..." } }
      // 2) ["a","b"]  -> intent "casual"
      if (!v) return { intent: "casual", lines: ["", ""] };
      if (Array.isArray(v)) return { intent: "casual", lines: [String(v[0]||""), String(v[1]||"")] };
      const intent = (v.intent || v.mood || "casual");
      const lines = v.lines || v.text || [];
      return { intent, lines: [String(lines[0]||""), String(lines[1]||"")], alt: v.alt || v.alts || null };
    }

    function rand(){ return Math.random(); }

    function humanDelay(base){
      return Math.max(0.01, base + (rand() - 0.5) * base * 0.6);
    }

    function confessionCorrect(line){
      let s = String(line || "");
      if (/\bdon't\b/i.test(s)){
        return s.replace(/\bdon't\s+/i, "");
      }
      if (/\blike\b/i.test(s)){
        return s.replace(/\blike\b/i, "love");
      }
      if (/\balone\b/i.test(s)){
        return s.replace(/\balone\b/i, "with you");
      }
      if (/\bnot\b/i.test(s)){
        return s.replace(/\bnot\s+/i, "");
      }
      if (!s.endsWith("...")) s = s.trim() + "...";
      return s;
    }

    const INTENT_CFG = {
      casual:      { mode: "clean",         speedMul: 1.00, pauseMul: 1.00 },
      fragil:      { mode: "hesitation",    speedMul: 1.25, pauseMul: 1.20 },
      incomodidad: { mode: "stumble_last",  speedMul: 1.05, pauseMul: 1.10 },
      dolor:       { mode: "rewrite_line2", speedMul: 1.10, pauseMul: 1.35 },
      confesion:   { mode: "confesion",     speedMul: 1.35, pauseMul: 1.40 },
      eco:         { mode: "clean_slow",    speedMul: 1.55, pauseMul: 1.60 }
    };

    const typeEngine = {
      done: false,
      state: "idle",
      intent: "casual",
      mode: "clean",

      targetA: "",
      targetB: "",
      targetB2: "",
      cleanedB: "",

      t: 0,
      pause: 0,
      next: 0,
      eraseUntil: 0,

      BASE_TYPE_SPEED: 0.12,
      ERASE_SPEED: 0.075,
      PAUSE_AFTER: 0.4,

      writeSpeed: 0.12,
      pauseAfter: 0.4,

      start({ intent, lines, alt }){
        this.done = false;
        this.intent = (intent || "casual").toLowerCase();
        const cfg = INTENT_CFG[this.intent] || INTENT_CFG.casual;

        this.mode = cfg.mode;
        this.writeSpeed = this.BASE_TYPE_SPEED * cfg.speedMul;
        this.pauseAfter = this.PAUSE_AFTER * cfg.pauseMul;

        this.targetA = String((lines && lines[0]) || "");
        this.targetB = String((lines && lines[1]) || "");
        this.targetB2 = "";
        this.cleanedB = "";

        curtainTextA.text = "";
        curtainTextB.text = "";

        if (this.mode === "rewrite_line2"){
          const b2 = alt && (alt.b2 || alt.final);
          if (b2){
            this.targetB2 = String(b2);
          } else {
            this.targetA = "the desire to simply";
            this.targetB = "not exis....";
            this.targetB2 = "exist...";
          }
        }

        if (this.mode === "confesion"){
          const corrected = (rand() < 0.20);
          if (corrected){
            this.mode = "confesion_corrected";
            this.cleanedB = confessionCorrect(this.targetB);
          } else {
            this.mode = "confesion_slow";
          }
        }

        this.state = "writeA";
        this.t = 0;
        this.pause = 0;
        this.next = humanDelay(this.writeSpeed);
      },

      _applyHumanity(ch, speedBase, extra){
        let base = speedBase;
        if (extra){
          if (ch === " " && rand() < 0.42) base *= 2.0;
          if (ch === "." && rand() < 0.85) base *= 2.4;
          if (ch === "," && rand() < 0.75) base *= 2.1;
        } else {
          if (ch === " " && rand() < 0.18) base *= 1.5;
          if (ch === "." && rand() < 0.45) base *= 1.8;
        }
        return base;
      },

      _writeStep(dt, textObj, target, speedBase, extraHuman){
        this.t += dt;
        if (this.t < this.next) return false;

        this.t = 0;
        const i = textObj.text.length;
        if (i >= target.length) return true;

        const ch = target[i];
        textObj.text += ch;
        this.next = humanDelay(this._applyHumanity(ch, speedBase, extraHuman));
        return false;
      },

      _eraseStep(dt, textObj, untilLen){
        this.t += dt;
        if (this.t < this.ERASE_SPEED) return false;

        this.t = 0;
        if (textObj.text.length > untilLen){
          textObj.text = textObj.text.slice(0, -1);
          return false;
        }
        return true;
      },

      update(dt){
        if (this.done) return;

        const m = this.mode;
        const extraHuman = (m === "hesitation" || m === "confesion_slow");

        if (this.state === "writeA"){
          const finished = this._writeStep(dt, curtainTextA, this.targetA, this.writeSpeed, extraHuman);
          if (finished){
            this.state = "writeB";
            this.t = 0;
            this.next = humanDelay(this.writeSpeed);
          }
          return;
        }

        if (this.state === "writeB"){
          const finished = this._writeStep(dt, curtainTextB, this.targetB, this.writeSpeed, extraHuman);
          if (!finished) return;

          if (m === "clean" || m === "clean_slow" || m === "hesitation" || m === "confesion_slow"){
            this.done = true;
            this.state = "done";
            return;
          }

          if (m === "stumble_last"){
            const s = this.targetB;
            const lastSpace = s.lastIndexOf(" ");
            if (lastSpace <= 0){
              this.done = true; this.state = "done"; return;
            }
            this.eraseUntil = lastSpace + 1;
            this.state = "eraseTail";
            this.t = 0;
            return;
          }

          this.state = "pause";
          this.pause = 0;
          return;
        }

        if (this.state === "pause"){
          this.pause += dt;
          if (this.pause < this.pauseAfter) return;

          if (m === "rewrite_line2" || m === "confesion_corrected"){
            this.state = "eraseAllB";
            this.t = 0;
            return;
          }

          this.done = true;
          this.state = "done";
          return;
        }

        if (this.state === "eraseAllB"){
          const finished = this._eraseStep(dt, curtainTextB, 0);
          if (!finished) return;

          this.state = "rewriteB";
          this.t = 0;
          this.next = humanDelay(this.writeSpeed * 0.95);
          return;
        }

        if (this.state === "rewriteB"){
          const target = (m === "rewrite_line2") ? this.targetB2 : this.cleanedB;
          const finished = this._writeStep(dt, curtainTextB, target, this.writeSpeed * 0.95, false);
          if (finished){
            this.done = true;
            this.state = "done";
          }
          return;
        }

        if (this.state === "eraseTail"){
          const finished = this._eraseStep(dt, curtainTextB, this.eraseUntil);
          if (!finished) return;

          this.state = "rewriteTail";
          this.t = 0;
          this.next = humanDelay(this.writeSpeed * 0.98);
          return;
        }

        if (this.state === "rewriteTail"){
          const currentLen = curtainTextB.text.length;
          const target = this.targetB;

          if (currentLen >= target.length){
            this.done = true;
            this.state = "done";
            return;
          }

          this.t += dt;
          if (this.t < this.next) return;

          this.t = 0;
          const ch = target[currentLen];
          curtainTextB.text += ch;
          this.next = humanDelay(this._applyHumanity(ch, this.writeSpeed * 0.98, false));
        }
      }
    };

    (function initCurtainVerse(){
      const picked = (window.pickNextVerse ? window.pickNextVerse() : ["the desire to simply", "exist..."]);
      const verse = normalizeVerse(picked);
      typeEngine.start({ intent: verse.intent, lines: verse.lines, alt: verse.alt });
    })();



    function drawCurtain(){
      const w = app.renderer.width / DPR;
      const h = app.renderer.height / DPR;

      // Si ya está abierta, ocultamos la cortina por completo
      if (curtainAlpha <= 0.001){
        curtain.visible = false;
        return;
      }
      curtain.visible = true;
      curtain.clear();

      // Base negra
      curtain.beginFill(0x000000, curtainAlpha);
      curtain.drawRect(0, 0, w, h);
      curtain.endFill();

      // Vignette suave (velo)
      const r = Math.max(w, h) * 0.75;
      curtain.beginFill(0x000000, Math.min(1, curtainAlpha) * 0.35);
      curtain.drawCircle(w * 0.5, h * 0.5, r);
      curtain.endFill();

      // Texto (Paso 2): verso centrado (triángulo invertido)
      const cx = w * 0.5;
      const cy = h * 0.45;
      curtainTextA.position.set(cx, cy);
      curtainTextB.position.set(cx, cy + 28);
      wakeHint.position.set(cx, cy + 72);

      // Respira suave (alpha)
      // Nota: la respiración se actualiza en el ticker (updateCurtainText)
    }


    
    function updateCurtainText(dt){
      curtainTextT += dt * (Math.PI * 2 / CURTAIN_TEXT_PERIOD);
      const b = 0.5 + Math.sin(curtainTextT) * 0.5;
      const a = 0.86 + b * CURTAIN_TEXT_AMP; // ~0.86..0.93

      // k sigue a la cortina; curtainTextFade se apaga rápido al despertar
      const k = Math.max(0, Math.min(1, curtainAlpha));
      const f = Math.max(0, Math.min(1, curtainTextFade));
      const kk = (k < 0.03) ? 0 : k; // evita texto fantasma cuando la cortina ya casi murió
      curtainTextA.alpha = a * kk * f;
      curtainTextB.alpha = a * kk * f;
      const vis = (curtainTextA.alpha > 0.01);
      curtainTextA.visible = vis;
      curtainTextB.visible = vis;

      // Hint: aparece solo cuando el verso terminó y aún no despertamos
      const ready = (typeEngine.done) && !wakingUp;
      const hintTarget = ready ? 0.65 : 0.0;
      // transición suave del hint
      wakeHint.alpha += (hintTarget - wakeHint.alpha) * 6.0 * dt;
      if (wakeHint.alpha < 0.01) wakeHint.alpha = 0;
      wakeHint.visible = wakeHint.alpha > 0;
      // y se apaga junto al verso en el despertar
      wakeHint.alpha *= f;
    }


    /* =========================================================
       6) LAYOUT / RESPONSIVE (móvil canon)
       ========================================================= */
    function layout(){
      const w = app.renderer.width / DPR;
      const h = app.renderer.height / DPR;

      // Valores actuales (móvil canon)
      const yFactor = 1.35;
      const baseFactor = 0.22;

      model.position.set(w / 2, h / yFactor);

      const base = Math.min(w / 1080, h / 1920);
      model.scale.set(base * baseFactor);

      // Evita que el modelo sobrepase el ancho
      const maxWidth = w * 0.88;
      const b = model.getBounds();
      if (b.width > maxWidth){
        model.scale.set(model.scale.x * (maxWidth / b.width));
      }

      drawNightOverlay();
      buildRects();
      buildStars();
      layoutPresentation();
      drawCurtain();
    }

    window.addEventListener("resize", layout, { passive: true });
    layout();


    /* =========================================================
       6.5) RESPIRACIÓN DEL MODELO (ParamRes) — móvil canon
       =========================================================
       - Orgánica (targets + fases), como en tu versión anterior
       - Mantiene el mundo "vivo" incluso sin historia
       ========================================================= */
    let breath = { value: 30, target: 30, speed: 0.035 };

    function pickTarget(){
      // Preferimos una respiración suave: mayormente cerca de -18..-22,
      // y a veces un poco más profunda.
      return Math.random() < 0.85
        ? (-18 - Math.random() * 4)     // -18..-22
        : (-24 - Math.random() * 1.5);  // -24..-25.5
    }

    let phase = "down";
    let nextSwitch = 0;

    function updateModelBreath(dt){
      nextSwitch -= dt;
      if (nextSwitch <= 0){
        if (phase === "down"){
          breath.target = pickTarget();
          breath.speed  = 0.045 + Math.random() * 0.015;
          phase = "up";
          nextSwitch = 0.9 + Math.random() * 0.4;
        } else {
          breath.target = 30;
          breath.speed  = 0.03 + Math.random() * 0.01;
          phase = "down";
          nextSwitch = 0.8 + Math.random() * 0.4;
        }
      }

      breath.value += (breath.target - breath.value) * breath.speed;
      setParam("ParamRes", breath.value);
    }

    /* =========================================================
       7) LOOP (v2)
       ========================================================= */
    app.ticker.add((delta) => {
      const dt = (delta / 60);

      // Cortina (texto)
      updateCurtainText(dt);
      typeEngine.update(dt);

      // Fade de cortina + audio
      if (curtainAlpha !== curtainTarget){
        curtainAlpha += (curtainTarget - curtainAlpha) * CURTAIN_FADE_SPEED * dt;
        if (Math.abs(curtainAlpha - curtainTarget) < 0.002) curtainAlpha = curtainTarget;
      }
      // Fade del verso (más rápido que la cortina)
      if (curtainTextFade !== curtainTextTarget){
        curtainTextFade += (curtainTextTarget - curtainTextFade) * CURTAIN_TEXT_FADE_SPEED * dt;
        if (Math.abs(curtainTextFade - curtainTextTarget) < 0.005) curtainTextFade = curtainTextTarget;
      }

      if (audioUnlocked && bgm.volume < 0.5){
        bgm.volume = Math.min(0.5, bgm.volume + dt * 0.05); // fade in ~8–10s
      }

      // Redibujar cortina cada frame (para que el fade sea visible)
      drawCurtain();

      // Modelo (ParamRes)
      updateModelBreath(dt);

      // Fondo (rects)
      updateRects(dt);

      // Estrellas
      updateStars(dt);

      // Zzz
      updateZzz(dt);

      // Historia (v4)
      updateStory(dt);

      // UI (v2)
      updateTitleGlow(dt);
      tapCooldown = Math.max(0, tapCooldown - dt);
      updateInitializingDots(dt);
    });

  })();
  </script>
</body>
</html>
