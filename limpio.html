<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Nivi IA ‚Äî Muy pronto</title>

  <link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@700&family=Inter:wght@300;500;700&display=swap" rel="stylesheet">

  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #05080f;
    }
    canvas {
      width: 100vw;
      height: 100vh;
      display: block;
    }
  </style>
</head>

<body>
  <canvas id="stage"></canvas>

  <!-- ===== LIBS (NO TOCAR ORDEN) ===== -->
  <script src="./libs/pixi.min.js"></script>
  <script src="./libs/live2dcubismcore.min.js"></script>
  <script src="./libs/cubism4.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pixi-live2d-display/dist/index.min.js"></script>

  <script>
  (async () => {

    /* =========================================================
       1) PIXI APP SETUP
       ========================================================= */
    PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.LINEAR;
    const DPR = Math.min(window.devicePixelRatio || 1, 2);

    const app = new PIXI.Application({
      view: document.getElementById("stage"),
      backgroundAlpha: 0,
      antialias: true,
      autoDensity: true,
      resolution: DPR,
      resizeTo: window,
      powerPreference: "high-performance"
    });

    /* ========== DEVICE ========== */
    const IS_MOBILE =
      window.matchMedia("(pointer: coarse)").matches ||
      Math.min(window.innerWidth, window.innerHeight) < 768;

    const IS_DESKTOP = !IS_MOBILE;

    function rand(min, max){ return min + Math.random() * (max - min); }

    /* =========================================================
       CAPAS / ORDEN (IMPORTANT√çSIMO)
       =========================================================
       1) rectLayer (fondo)
       2) model
       3) nightOverlay (velo)            -> oscurece Nivi
       4) starLayer (luci√©rnagas)        -> por arriba del velo
       5) zzzLayer
       6) uiLayer (textos de presentaci√≥n) -> arriba de todo
    */

    const rectLayer = new PIXI.Container();
    const starLayer = new PIXI.Container();
    const zzzLayer  = new PIXI.Container();
    const uiLayer   = new PIXI.Container();

    const nightOverlay = new PIXI.Graphics();

    app.stage.addChild(rectLayer);

    /* ================= MODEL ================= */
    const model = await PIXI.live2d.Live2DModel.from(
      "assets/models/nivi/nivi.model3.json"
    );
    model.anchor.set(0.5, 1);

    app.stage.addChild(model);
    app.stage.addChild(nightOverlay);
    app.stage.addChild(starLayer);
    app.stage.addChild(zzzLayer);
    app.stage.addChild(uiLayer);


    /* ================= HELPERS ================= */
    function core(){ return model.internalModel.coreModel; }
    function clamp(v,min,max){ return Math.max(min,Math.min(max,v)); }
    function setParam(id,v){ core().setParameterValueById(id, clamp(v,-30,30)); }

    /* =========================================================
       FONDO RECT√ÅNGULOS (lateral, suave)
       ========================================================= */
    const rectLayers = [];
    const rectConfig = [
      { count: IS_DESKTOP ? 10 : 8,  speed: 0.040, wMin: 120, wMax: 200, hMin: 4, hMax: 8, alpha: 0.015 },
      { count: IS_DESKTOP ? 14 : 12, speed: 0.070, wMin: 60,  wMax: 120, hMin: 4, hMax: 8, alpha: 0.025 },
      { count: IS_DESKTOP ? 18 : 16, speed: 0.100, wMin: 30,  wMax: 60,  hMin: 3, hMax: 6, alpha: 0.035 }
    ];

    function makeRect(conf, w, h){
      const g = new PIXI.Graphics();
      const rw = rand(conf.wMin, conf.wMax);
      const rh = rand(conf.hMin, conf.hMax);
      g.beginFill(0xAAC8FF, conf.alpha);
      g.drawRect(0, 0, rw, rh);
      g.endFill();

      g.x = Math.random() * w;
      g.y = Math.random() * h;

      rectLayer.addChild(g);

      return { g, rw, rh, vx: conf.speed * (Math.random() < 0.5 ? -1 : 1) };
    }

    /* =========================================================
       2) BACKGROUND LAYERS (rects / gradients)
       ========================================================= */

    function buildRects(){
      rectLayer.removeChildren();
      rectLayers.length = 0;

      const w = app.renderer.width / DPR;
      const h = app.renderer.height / DPR;

      rectConfig.forEach(conf => {
        const arr = [];
        for (let i = 0; i < conf.count; i++){
          arr.push(makeRect(conf, w, h));
        }
        rectLayers.push(arr);
      });
    }

    /* =========================================================
       ESTRELLAS ‚ÄúLUCI√âRNAGAS‚Äù
       ========================================================= */
    const stars = [];
    const STAR_COUNT = IS_DESKTOP ? 55 : 40;

    function drawStar(s, alpha){
      s.g.clear();
      s.g.beginFill(0xFFFFFF, alpha);
      s.g.drawCircle(0, 0, s.r);
      s.g.endFill();
      s.g.x = s.x;
      s.g.y = s.y;
    }

    function makeStar(w, h){
      const g = new PIXI.Graphics();
      starLayer.addChild(g);
      return {
        g,
        x: Math.random() * w,
        y: Math.random() * h,
        r: rand(0.4, 2.0),
        baseAlpha: rand(0.18, 0.40),
        phase: Math.random() * Math.PI * 2,
        pulseSpeed: rand(0.25, 0.60),
        vx: (Math.random() - 0.8) * 0.16,
        vy: (Math.random() - 0.8) * 0.16,
        driftT: rand(2.0, 6.0)
      };
    }

    /* =========================================================
       3) STARS
       ========================================================= */

    function buildStars(){
      starLayer.removeChildren();
      stars.length = 0;

      const w = app.renderer.width / DPR;
      const h = app.renderer.height / DPR;

      for (let i = 0; i < 100; i++){
        stars.push(makeStar(w, h));
      }
    }

    /* =========================================================
       VELO NOCHE (encima del modelo, debajo de estrellas)
       ========================================================= */
    function drawNightOverlay(){
      const w = app.renderer.width / DPR;
      const h = app.renderer.height / DPR;

      nightOverlay.clear();
      nightOverlay.beginFill(0x020611, 0.18);
      nightOverlay.drawRect(0, 0, w, h);
      nightOverlay.endFill();
    }

    /* =========================================================
       TEXTOS DE PRESENTACI√ìN
       ========================================================= */
    const titleText = new PIXI.Text("Nivi?", {
      fontFamily: "Inter",
      fontWeight: "700",
      fontSize: 64,
      fill: 0xEAF1FF,
      align: "center",
      letterSpacing: 1,

      dropShadow: true,
      dropShadowColor: 0xAFCBFF,
      dropShadowBlur: 6,
      dropShadowAngle: Math.PI / 2,
      dropShadowDistance: 0,
      dropShadowAlpha: 0.35
    });
    titleText.anchor.set(0.5);

    const subText = new PIXI.Text("COMING SOON", {
      fontFamily: "Inter",
      fontWeight: "500",
      fontSize: 18,
      fill: 0xAFC2E8,
      align: "center",
      letterSpacing: 4
    });
    subText.anchor.set(0.5);

    // üëá Cambiado (antes: "28 de enero")
    const dateText = new PIXI.Text("hm‚Ä¶", {
      fontFamily: "Inter",
      fontWeight: "300",
      fontSize: 18,
      fill: 0xAFC2E8,
      align: "center",
      letterSpacing: 2
    ,
      dropShadow: true,
      dropShadowColor: 0xAFCBFF,
      dropShadowBlur: 3,
      dropShadowAngle: Math.PI / 2,
      dropShadowDistance: 0,
      dropShadowAlpha: 0.18
    });
    dateText.anchor.set(0.5);
    // Segundo texto para transiciones fluidas (crossfade)
    const dateTextB = new PIXI.Text(dateText.text, dateText.style);
    dateTextB.anchor.set(0.5);
    dateTextB.alpha = 0;

    /* =========================================================
       5) STORY DATA + STORY STATE + CROSSFADE CONFIG
       (la historia avanza sola; el mundo sigue vivo)
       =========================================================

       HISTORIA EN GOTAS (promesa) ‚Äî transiciones fluidas + respiraci√≥n lenta compartida
       FINAL LIMPIO: la historia se detiene al llegar al √∫ltimo verso,
       pero el mundo (nieve/estrellas/respiraci√≥n) sigue vivo.
       ========================================================= */
    const HM_BASE = "hm‚Ä¶";

    const STORY = [
      "Venus‚Ä¶",
      "so√±√©‚Ä¶",
      "con tu luz‚Ä¶",
      "en la nieve‚Ä¶",
      "no habl√©‚Ä¶",
      "pero escuch√©‚Ä¶",
      "tu nombre‚Ä¶",
      "dentro‚Ä¶",
      "de m√≠‚Ä¶",
      "espera‚Ä¶",
      "casi‚Ä¶",
      "despierto‚Ä¶"
    ];

    // Intervalo entre gotas (m√°s largo, agradable)
    let nextDropIn = 12 + Math.random() * 6; // 12‚Äì18s

    // Respiraci√≥n lenta compartida (todas las frases comparten el mismo "aire")
    let breathT = Math.random() * Math.PI * 2;
    const BREATH_PERIOD = 9.5;      // segundos por ciclo (m√°s largo)
    const BREATH_ALPHA_AMP = 0.07;  // 7% de alpha

    // Crossfade entre frases (suave, sin flashes)
    let shownText = HM_BASE;
    let nextText = null;

    let xState = "idle";     // idle -> fade -> hold -> idle, o promise
    let xT = 0;

    const X = {
      fade: 1.10,  // crossfade m√°s lento y sedoso
      hold: 1.00
    };

    const PROMISE_ALPHA = 0.96;
    let storyDone = false; // when true: stop story progression but keep the world alive
    let storyIndex = 0;

    /* =========================================================
       6) AUDIO (opc.)
       ========================================================= */

    // Micro "tink" opcional
    const TINK_ENABLED = true;

    let audioReady = false;
    let audioCtx = null;

    function ensureAudio(){
      if (audioReady) return;
      try{
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        audioReady = true;
      }catch(e){
        audioReady = false;
      }
    }

    function playTink(){
      if (!TINK_ENABLED) return;
      if (!audioReady || !audioCtx) return;

      const t0 = audioCtx.currentTime;
      const o  = audioCtx.createOscillator();
      const g  = audioCtx.createGain();

      o.type = "sine";
      o.frequency.setValueAtTime(720, t0);
      o.frequency.exponentialRampToValueAtTime(520, t0 + 0.12);

      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(0.009, t0 + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.22);

      o.connect(g);
      g.connect(audioCtx.destination);

      o.start(t0);
      o.stop(t0 + 0.24);
    }

    app.view.addEventListener("pointerdown", () => {
      ensureAudio();
      if (audioCtx && audioCtx.state === "suspended") audioCtx.resume();
    }, { passive:true });

    function scheduleNextDrop(){
      nextDropIn = 12 + Math.random() * 6;
    }

    function startDrop(){
      // If we've reached the end, lock into the final line cleanly.
      if (storyDone) return;

      const finalLine = STORY[STORY.length - 1];

      if (storyIndex >= STORY.length){
        storyDone = true;
        shownText = finalLine;

        xState = "final";
        xT = 0;
        nextText = null;

        dateText.text  = shownText;
        dateText.alpha = PROMISE_ALPHA;

        dateTextB.text  = "";
        dateTextB.alpha = 0;

        // Prevent any future scheduling from accidentally firing.
        nextDropIn = Number.POSITIVE_INFINITY;
        return;
      }

      nextText = STORY[storyIndex];
      storyIndex++;

      // Configura ambos textos para crossfade
      dateText.text = shownText;
      dateTextB.text = nextText;

      dateText.alpha = 1.0;
      dateTextB.alpha = 0.0;

      xState = "fade";
      xT = 0;

      playTink();
    }

    function applySharedBreath(dt){
      breathT += dt * (Math.PI * 2 / BREATH_PERIOD);
      const b = 0.5 + Math.sin(breathT) * 0.5; // 0..1
      const a = 1.0 - BREATH_ALPHA_AMP/2 + b * BREATH_ALPHA_AMP;

      // borde respirando suave
      const shA = 0.12 + b * 0.18;
      const shB = 2.0 + b * 2.4;

      dateText.style.dropShadowAlpha = shA;
      dateText.style.dropShadowBlur  = shB;
      dateTextB.style.dropShadowAlpha = shA;
      dateTextB.style.dropShadowBlur  = shB;

      return a;
    }

    function updateStory(dt){
      // Shared breath always runs (world stays alive even when story ends)
      const breathA = applySharedBreath(dt);

      // Final lock: keep the last line breathing, never progress again.
      if (storyDone || xState === "final"){
        dateText.text = shownText;
        dateText.alpha = PROMISE_ALPHA * breathA;
        dateTextB.text = "";
        dateTextB.alpha = 0;
        return;
      }

      if (xState === "idle"){
        dateText.text = shownText;
        dateText.alpha = (shownText === HM_BASE) ? 1.0 : 0.95 * breathA;
        dateTextB.alpha = 0;

        // Only progress if not done.
        nextDropIn -= dt;
        if (nextDropIn <= 0){
          scheduleNextDrop();
          startDrop();
        }
        return;
      }

      if (xState === "fade"){
        xT += dt;
        const t = Math.min(1, xT / X.fade);
        const e = t * t * (3 - 2 * t); // smoothstep

        dateText.alpha  = (1 - e) * 0.95 * breathA;
        dateTextB.alpha = e * 0.95 * breathA;

        if (t >= 1){
          shownText = nextText ?? shownText;
          nextText = null;

          dateText.text = shownText;
          dateText.alpha = 0.95 * breathA;
          dateTextB.alpha = 0;

          // If we just landed on the final line, lock cleanly.
          if (shownText === STORY[STORY.length - 1]){
            storyDone = true;
            xState = "final";
            nextDropIn = Number.POSITIVE_INFINITY;
            return;
          }

          xState = "idle";
          xT = 0;
        }
        return;
      }

      // Fallback: reset safely
      xState = "idle";
    }

    // Estado inicial
    shownText = HM_BASE;
    dateText.text = HM_BASE;
    dateText.alpha = 1.0;
    dateTextB.text = HM_BASE;
    dateTextB.alpha = 0;
    // Textos inferiores estilo la imagen de referencia
    const initText = new PIXI.Text("Initializing", {
      fontFamily: "Inter",
      fontWeight: "300",
      fontSize: 16,
      fill: 0xAFC2E8,
      align: "center",
      letterSpacing: 1
    });
    initText.anchor.set(0.5);

    const availText = new PIXI.Text("Available January 1", {
      fontFamily: "Inter",
      fontWeight: "500",
      fontSize: 18,
      fill: 0xAEA69C, // tono c√°lido polvo

      dropShadow: true,
      dropShadowColor: 0xF2EFEA, // brillo muy suave
      dropShadowBlur: 2.5,
      dropShadowAngle: Math.PI / 2,
      dropShadowDistance: 0,
      dropShadowAlpha: 0.18
    });
    availText.anchor.set(0.5);

/* =========================================================
   TEXTOS: puntos cargando + frases aleatorias por toque
   ========================================================= */

// 6 frases tecnol√≥gicas (susurradas)
const TECH_LINES = [
  "Sincronizando",
  "Calibrando memoria",
  "Se√±al detectada",
  "Sistema en reposo",
  "Latencia emocional",
  "Protocolo de espera"
];


let initBase = "Initializing"; // base para los puntos
let dots = 0;
let dotsTimer = 0;
const DOTS_INTERVAL = 0.45; // segundos (0.35‚Äì0.60 queda bonito)

let lastIndex = -1;      // para no repetir la misma frase seguida
let tapCooldown = 0;     // evita spam muy r√°pido

function pickRandomIndex(len, avoid){
  if (len <= 1) return 0;
  let i = Math.floor(Math.random() * len);
  if (i === avoid) i = (i + 1) % len;
  return i;
}

function applyRandomText(){
  const i = pickRandomIndex(TECH_LINES.length, lastIndex);
  lastIndex = i;

  initBase = TECH_LINES[i];

  // fuerza refresco inmediato de puntos
  dotsTimer = DOTS_INTERVAL;
}

function updateInitializingDots(dt){
  dotsTimer += dt;
  if (dotsTimer >= DOTS_INTERVAL){
    dotsTimer = 0;
    dots = (dots + 1) % 4; // 0..3
  }
  initText.text = initBase + ".".repeat(dots);
}

// Estado inicial aleatorio
applyRandomText();

// Tap / click para cambiar textos
app.view.addEventListener("pointerdown", () => {
  if (tapCooldown > 0) return;
  tapCooldown = 0.18; // 180ms, suave
  applyRandomText();
}, { passive: true });

    // ‚Äúmicro l√≠nea‚Äù tipo poster para separar (muy sutil)
    const rule = new PIXI.Graphics();

        uiLayer.addChild(titleText, subText, rule, dateText, dateTextB, initText, availText);
// Respiraci√≥n del brillo del t√≠tulo
    let titleGlowT = Math.random() * Math.PI * 2;

    function layoutPresentation(){
      const w = app.renderer.width / DPR;
      const h = app.renderer.height / DPR;

      // escalado responsive
      const titleSize = IS_MOBILE ? 44 : 64;
      const subSize   = IS_MOBILE ? 14 : 18;
      const dateSize  = IS_MOBILE ? 14 : 18;
      const initSize  = IS_MOBILE ? 12 : 14;
      const availSize = IS_MOBILE ? 14 : 16;

      titleText.style.fontSize = titleSize;
      subText.style.fontSize   = subSize;
      dateText.style.fontSize  = dateSize;
      initText.style.fontSize  = initSize;
      availText.style.fontSize = availSize;

      // posiciones estilo poster (arriba, centrado)
      const topY = IS_MOBILE ? h * 0.10 : h * 0.11;

      titleText.x = w * 0.5;
      titleText.y = topY;

      subText.x = w * 0.5;
      subText.y = topY + (IS_MOBILE ? 42 : 58);

      // l√≠nea fina
      rule.clear();
      rule.lineStyle(1, 0xAFC2E8, 0.25);
      const lineW = Math.min(260, w * 0.55);
      rule.moveTo(w * 0.5 - lineW/2, subText.y + (IS_MOBILE ? 18 : 22));
      rule.lineTo(w * 0.5 + lineW/2, subText.y + (IS_MOBILE ? 18 : 22));

      dateText.x = w * 0.5;
      dateText.y = subText.y + (IS_MOBILE ? 38 : 46);
      dateTextB.x = dateText.x;
      dateTextB.y = dateText.y;

      // textos inferiores (centrados)
      const bottomY = IS_MOBILE ? h * 0.86 : h * 0.88;
      initText.x = w * 0.5;
      initText.y = bottomY;

      availText.x = w * 0.5;
      availText.y = bottomY + (IS_MOBILE ? 22 : 24);

      uiLayer.alpha = 0.95;
    }

    /* ================= LAYOUT ================= */
    /* =========================================================
       8) LAYOUT / RESPONSIVE
       ========================================================= */

    function layout(){
      const w = app.renderer.width / DPR;
      const h = app.renderer.height / DPR;

      const yFactor = IS_MOBILE ? 1.35 : 1.2;
      model.position.set(w/2, h/yFactor);

      const base = Math.min(w/1080, h/1920);
      const baseFactor = IS_MOBILE ? 0.22 : 0.35;
      model.scale.set(base * baseFactor);

      const maxWidth = w * 0.88;
      const b = model.getBounds();
      if (b.width > maxWidth){
        model.scale.set(model.scale.x * (maxWidth / b.width));
      }

      drawNightOverlay();
      buildRects();
      buildStars();
      layoutPresentation();
    }
    window.addEventListener("resize", layout, { passive:true });
    layout();

    /* ================= BREATH (ParamRes) ================= */
    let breath = { value: 30, target: 30, speed: 0.035 };
    function pickTarget(){
      return Math.random() < 0.85
        ? -18 - Math.random() * 4
        : -24 - Math.random() * 1.5;
    }
    let phase = "down", nextSwitch = 0;

    /* ================= Zzz ================= */
    const zzzs = [];
    const Z_SEQUENCE = [
      { size: 1.2, delay: 0.0, grow: true  },
      { size: 0.8, delay: 0.9, grow: false },
      { size: 0.4, delay: 2.0, grow: false }
    ];

    /* =========================================================
       7) AMBIENT ENTITIES (Zzz / wander)
       ========================================================= */

    function spawnZzzCycle(){
      const baseX = model.x;
      const baseY = model.y - model.height + 20;

      Z_SEQUENCE.forEach(seq => {
        const z = new PIXI.Text("Z", {
          fontFamily: "Comic Neue",
          fontSize: (IS_MOBILE ? 18 : 24) * seq.size,
          fill: 0xD6DEFF
        });
        z.anchor.set(0.5);
        z.alpha = 0;
        z.x = baseX;
        z.y = baseY;

        if (seq.grow) z.scale.set(0.4);

        zzzLayer.addChild(z);

        zzzs.push({
          z,
          life: -seq.delay,
          lifeMax: 4.2,
          rise: 18 + Math.random() * 6,
          drift: 6 + Math.random() * 4,
          swayPhase: Math.random() * Math.PI * 2,
          swaySpeed: 0.6 + Math.random() * 0.3,
          grow: seq.grow
        });
      });
    }

    let zzzTimer = 0;
    let nextZzz = 3.2;

    /* ================= LOOP ================= */
    app.ticker.add((delta)=>{
      const dt = delta / 60;
      const w = app.renderer.width / DPR;
      const h = app.renderer.height / DPR;

      // Rect√°ngulos (movimiento lateral)
      for (let li = 0; li < rectLayers.length; li++){
        const arr = rectLayers[li];
        for (let i = 0; i < arr.length; i++){
          const r = arr[i];
          r.g.x += r.vx;

          if (r.vx > 0 && r.g.x > w + 40){
            r.g.x = -r.rw - 40;
            r.g.y = Math.random() * h;
          } else if (r.vx < 0 && r.g.x < -r.rw - 40){
            r.g.x = w + 40;
            r.g.y = Math.random() * h;
          }
        }
      }

      // Estrellas luci√©rnaga
      for (let i = 0; i < stars.length; i++){
        const s = stars[i];

        s.phase += (s.pulseSpeed * dt);
        const pulse = 0.5 + Math.sin(s.phase) * 0.5;
        const alpha = s.baseAlpha + pulse * 0.25;

        s.driftT -= dt;
        if (s.driftT <= 0){
          s.vx = (Math.random() - 0.5) * 0.12;
          s.vy = (Math.random() - 0.5) * 0.12;
          s.driftT = rand(2.0, 6.0);
        }

        s.x += s.vx;
        s.y += s.vy;

        if (s.x < -10) s.x = w + 10;
        if (s.x >  w + 10) s.x = -10;
        if (s.y < -10) s.y = h + 10;
        if (s.y >  h + 10) s.y = -10;

        drawStar(s, alpha);
      }

      // Respiraci√≥n (ParamRes)
      nextSwitch -= dt;
      if (nextSwitch <= 0){
        if (phase === "down"){
          breath.target = pickTarget();
          breath.speed  = 0.045 + Math.random() * 0.015;
          phase = "up";
          nextSwitch = 0.9 + Math.random() * 0.4;
        } else {
          breath.target = 30;
          breath.speed  = 0.03 + Math.random() * 0.01;
          phase = "down";
          nextSwitch = 0.8 + Math.random() * 0.4;
        }
      }
      breath.value += (breath.target - breath.value) * breath.speed;
      setParam("ParamRes", breath.value);

      // Spawn Zzz
      zzzTimer += dt;
      if (zzzTimer > nextZzz){
        spawnZzzCycle();
        zzzTimer = 0;
        nextZzz = 3.0 + Math.random() * 0.8;
      }
      // Update Zzz
      for (let i = zzzs.length - 1; i >= 0; i--){
        const p = zzzs[i];
        p.life += dt;
        if (p.life < 0) continue;

        const t = p.life / p.lifeMax;

        if (t < 0.25) p.z.alpha = t / 0.25;
        else if (t > 0.85) p.z.alpha = (1 - t) / 0.15;
        else p.z.alpha = 1;

        if (p.grow && t < 0.35){
          const sc = 0.4 + (t / 0.35) * 0.6;
          p.z.scale.set(sc);
        }

        p.z.y -= p.rise * dt;
        p.swayPhase += dt * p.swaySpeed;
        p.z.x += Math.sin(p.swayPhase) * p.drift * dt;

        if (t >= 1){
          zzzLayer.removeChild(p.z);
          p.z.destroy();
          zzzs.splice(i, 1);
        }
      }

      // Respiraci√≥n del brillo en "Nivi?"
      titleGlowT += dt * 0.6;
      const glowPulse = 0.5 + Math.sin(titleGlowT) * 0.5;
      titleText.style.dropShadowAlpha = 0.25 + glowPulse * 0.20;
      titleText.style.dropShadowBlur  = 5 + glowPulse * 3;

      // Historia en gotas (hm‚Ä¶)
      updateStory(dt);

      // Cooldown + puntos animados en "Initializing..."
      tapCooldown = Math.max(0, tapCooldown - dt);
      updateInitializingDots(dt);
    });

  })();
  </script>
</body>
</html>
